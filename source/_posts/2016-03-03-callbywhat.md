---
title: 值传递和引用传递
date: 2016/03/03
tags: [javascript]
excerpt: 堆和栈的概念，javascript的值传递和引用传递知识点解析总结
---

## 概念

#### 数据类型
   
在 javascript 中数据类型可以分为两类
- **原始数据类型值** :primitive type，比如Undefined,Null,Boolean,Number,String
- **引用类型值** :也就是对象类型 Object type,比如Object,Array,Function,Date等

#### 内存分配机制

有计算机基础的同学知道，在内存中，有堆和栈的概念。

不同的内存分配机制也带来了不同的访问机制,声明变量时不同的内存分配如下:
- 原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。
- 引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。

## 传递方式

#### 值传递

通过下面的代码看下java中的值传递形式：

```java
public static void changeValue(int x) {  
x = x *2;  
}  

int num = 5;  
System.out.println(num);  // 5
changeValue(num);  
System.out.println(num);  // 5
```
**说明：**num作为参数传递给changeValue()方法时，是将内存空间中num所指向的那个存储单元中存放的值，即"5",传送给了changeValue()方法中的x变量。此时有num和x两个变量对应不同的存储区域，只不过两者值相同。然后，在changeValue()方法中对x的一切操作都是针对x所指向的这个存储单元，与num所指向的那个存储单元没有一点关系。

值传递的意思是对值生成一个副本进行接下来的操作，所有的操作只影响这个后生成的副本，而原有值是不会变化的。

所以，在函数调用之后，num所指向的存储单元的值还是没有发生变化，这就是所谓的“值传递”！

#### 引用传递

再看"假引用"传递的例子：

```java
class Person {  
public static String name = "Jack";  
}  

//定义一个改变对象属性的方法  
public static void changeName(Person p) {  
p.name = "Rose";  
}  
 
public static void main(String[] args) {  
//定义一个Person对象，person是这个对象的引用  
Person person = new Person();  
System.out.println(person.name);  // Jack
changeName(person);  
System.out.println(person.name); // Rose
}  
```

**解释：**先说明其实这里还是值传递！虽然person是Person类实例的一个引用，也就是说person这个值实际存储的是堆内存中new Person()这个实例的存储地址而已。不管存储的是什么，person依然不过是和上面例子中num相同的变量值而已。所以当将person传入函数，和num的值传递形式是一样的！

结果不同的原因是：这时传入的person是实际实例对象的引用，也就是说原有的person和现有的函数中虽然是在两个地方存储，但都指向了实际实例对象的存储地址。所以由于前后两者都指向同一个实例的引用，所以函数中实际改变的是这个引用指向地址中存储的实例对象，因此结果是Rose。


虽然第一个例子看上去没有改变`原有值`，而第二个例子却改变了，但这只是表象而已。

**所以Java语言中只有值传递而没有引用传递！**

然后再看真正的引用传递：

```c
void Modify(int p, int * q)
{
    p = 27; // 按值传递，p是实参a的副本(p和a存在两个不同的地方), 所以只有p被修改
    *q = 27; // q是b的引用(27赋值给了q指向的引用地址处的值)，b被修改
}
int main()
{
    int a = 1;
    int b = 1;
    Modify(a, &b);   // a 按值传递, b 按引用传递,
                     // a 未变化, b 改变了
    return(0);
}
```

**总结：**

- 值传递：

形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

- 引用传递：

形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

## Javascript

#### 基本类型

首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。原理和Java中的例子相同。但是为什么涉及到原始类型与引用类型的值时仍然有区别呢，还不就是因为内存分配时的差别。

#### 对象类型


```js
var obj = {x : 1};
function foo(o) {
    o.x = 3;
}
foo(obj);
console.log(obj.x); // 3, 被修改了!
```
说明o和obj是同一个对象，o不是obj的副本。所以不是按值传递。但是否说明JS的对象就是按引用传递的呢？我们再看下面的例子：
```js
var obj = {x : 1};
function foo(o) {
    o = 100;
}
foo(obj);
console.log(obj.x); // 仍然是1, obj并未被修改为100.
```

如果是按引用传递，修改形参o的值，应该影响到实参才对。但这里修改o的值并未影响obj。因此JS中的对象并不是按引用传递。那么究竟对象的值在JS中如何传递的呢？

查了很多文章和回答，最后更愿意用`按对象传递`这个概念来解释。

> 该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。如下面例子中，不可以通过修改形参o的值，来修改obj的值。

```js
var obj = {x : 1};
function foo(o) {
    o = 100;
}
foo(obj);
console.log(obj.x); // 仍然是1, obj并未被修改为100.
```

> 然而，虽然引用是副本，引用的对象是相同的。它们共享相同的对象，所以修改形参对象的属性值，也会影响到实参的属性值。

```js
var obj = {x : 1};
function foo(o) {
    o.x = 3;
}
foo(obj);
console.log(obj.x); // 3, 被修改了!
```

## 饿了么面试题

```js
[1] == [1] ?  true or false
```
卧槽！！！ 变态！！！

哈哈哈。吐槽完来解答。很明显你觉着是true那他肯定是false。至于为什么，我来给你解释。

还记得上面的解答吗？基本类型和对象类型的存值方式是不同的，基本类型是存储值而对象类型是存储堆内存地址，也就是实际值的地址引用。所以当我们写下第一个`[1]`的时候，系统为他开辟一个对空间存值并且开辟一个栈控件存这个值控件的地址；然后按照相同的路子为第二个`[1]`也进行操作一番。然后我们拿两个地址(注意这里的两个地址很明显是不同的哦，因为是不同地方的地址的引用，虽然这两个地方存储的值相同),自然是false!!!

## 阅读理解题

看完了上边的内容，下面做题测试掌握情况。一脸正经~

有如下两段代码：

```js
var a = {n:1}; 
var b = a;  
a = {n:2}; 
a.x = a ;
console.log(a.x); // ?
console.log(b.x); // ?
```

题目分析：javascript中对象变量存储的到底是什么？以上边这段代码为例：a实际存储的不是`{n:1}`，而是这个对象在内存中实际的存储位置，也就是堆内存地址。看好了，a存储的是`{n:1}`的引用！首先将`{n:1}`的引用赋值给a，然后a赋值给b，这时a和b都指向了`{n:1}`。接下来对又给a赋值，此时a便指向了`{n:2}`，而b依然指向`{n:1}`保持不变。所以接下来对a的所有操作，已经和b脱离关系。所以最后的答案是a.x为`{a: "a", x: a}`，而b.x是`undefined`。

```js
var a = {n:1}; 
var b = a;  
a.x = a = {n:2}; 
console.log(a.x);
console.log(b.x);
```
题目解析：这就厉害了，又升高一级。前两句依然是将a和b都指向`{n:1}`。接下来a.x=a={n:2}这句是重点，其中涉及到的一是第一道题目里的引用问题，还有就是运算符优先级的问题。`.`这个点号的优先级要高于赋值`=`，所以先声明a指向的对象的x属性，此时a和b共同指向的{n:1}这个对象有了一个undefined的x属性，再然后从左向右顺序开始赋值。a.x指向{n:2}，因为这时a和b的指向还是相同的，所以a.x=b.x={n:2}。然后又将a={n:2}，所以答案是a.x为undefined，而b.x为{n:2}。

<div class="tip">
参考文章:  [参考文章1](http://bosn.me/js/js-call-by-sharing/) | [参考文章2](http://guhanjie.iteye.com/blog/1683637)
</div>
