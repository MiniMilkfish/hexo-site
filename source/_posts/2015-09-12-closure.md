---
title: javascript中的闭包
tags: [javascript]
date: 2015-09-12
---
本文整理自`《你不知道的JavaScript》`一书。

闭包是初级前端工程师在被面试或者高级工程师面试别人的时候基本都会提及的一个概念。

闭包就是一个概念而已，比起马列主义的条条框框、霍金的时间简史等概念来说真的是简单的不能再简单。当初不明白的时候云里雾里，看代码都能懂，但是就是不知道怎么就成了闭包或者闭包到底是个啥东西。但是，经过一遍又一遍的揣摩和随着自己对javascript的掌握程度越来越深入，慢慢的有一天你会发现原来闭包也就这么回事。

## 概念

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

好了，我们开始解读这个概念。上边的这句话还不是很清晰准确，要我自己的理解加以概括的话，我会这样来总结。闭包是一个函数，这个函数能够在原本的词法作用于之外执行的时候还能记住并访问他当时所在的词法作用域的变量。

然后我来解释我自己的这个总结。

首先，抓住重点，闭包是一个函数。这句话没有错误，但是我自己潜意识里还是把它理解成为一种情景，一种比较特殊的关于函数特性的情景。也就是说闭包的产生必然是跟函数相关的，因为javascript是函数作用域的。

然后就说作用域，产生闭包的前提是某个函数在原本的词法作用域外执行，但是这个函数却像在最开始的作用域位置一样访问他能访问的变量。

## 实例

下面用代码来解释这个概念：

- 1.单纯的嵌套作用域非闭包

``` javascript
var a = 1;
function foo() {
    var b = 2;
    function bar() {
    var c = 3 ;
    console.log( a + b + c ); // 6
    }
    bar();
}
foo();
```

这段代码可以在解释嵌套作用域的地方看到，函数bar()能够访问自己作用域内的变量c、嵌套函数foo作用域内的变量b和全局作用域内的变量a，这就是作用域链和作用域嵌套的相关知识，但是不是闭包。

- 2.常见形式的闭包

``` javascript
function foo() {
    var a = 2;
    function bar() {
    console.log( ++a );
    }
    return bar;
}
var baz = foo();
baz(); // 3
baz(); // 4
baz(); // 5
```

看到了，这段代码跟上段代码的区别就是bar被拿到了原有的作用域外执行，但是结果依然正确不报错。

函数bar() 的词法作用域能够访问foo() 的内部作用域。然后我们将bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将bar所引用的函数对象本身当作返回值。在foo() 执行后，其返回值（也就是内部的bar() 函数）赋值给变量baz并调用baz()，实际上只是通过不同的标识符引用调用了内部的函数bar()。bar()显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。

在foo() 执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去foo()的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是bar() 本身在使用。

拜bar() 所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar() 在之后任何时间进行引用。

- 再举几个栗子

{% img [] http://ojd8i48oc.bkt.clouddn.com/20160912%E9%97%AD%E5%8C%85/jugelizi.jpg 80 %}

``` javascript
function foo() {
var a = 2;
function baz() {
console.log( a ); // 2
}
bar( baz );
}
function bar(fn) {
fn();
}
```

无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。

无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

``` javascript
function wait(message) {
setTimeout( function timer() {
console.log( message );
}, 1000 );
}
wait( "Hello, closure!" );
```

又比如这个，timer函数的运行是在wait执行完后，这时的词法作用域已经不是之前声明函数时的那个词法作用域，所以这也产生了闭包，很明显，这个栗子可以看做内存泄漏，但是一般情况这点小代码
也不会占用到太多内存，所以就算你不理解闭包但是无意间还是会写出很多闭包的代码，而且往往都夹杂着内存泄露等副作用，但是你却无所感知。

## 用闭包模拟私有化

闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。

诸如 Java 在内的一些语言支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。

对此，JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。

```js
var Counter = function() {
  var privateValue = 0;

  return {
    add: function() {
      privateValue++;
      console.log(privateValue);
    },
    subtract: function() {
      privateValue--;
      console.log(privateValue);
    }
  };
};

var counter1 = new Counter();
var counter2 = new Counter();
counter1.add(); // 1
counter1.add(); // 2
counter1.add(); // 3
counter1.subtract(); // 2

counter2.add(); // 1
```

> Counter可做类构造出自己的实例对象。Counter包含一个私有化变量privateValue，外部只能通过其公共方法add或subtract访问该内部变量。不同的实例之间词法作用域不会共享(counter1和counter2成员变量相互独立)。

## 性能考量

如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。

例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。

我知乎上有关于闭包的一个简短解答，可以跳过去看下。[在面试中，怎样能通俗易懂又不白痴的回答出面试官提出的js中闭包问题？](https://www.zhihu.com/question/52491175)