---
title: 模块化开发浅析
author: Yeluo
tags: [模块化]
date: 2016-02-15
---

# 模块化开发的必然性

模块化概念从很早就开始提出且逐步尝试，node在服务端的require模式，浏览器端的requirejs、seajs等等。几年过去，requirejs、seajs早已停止更新，但是模块加载的工具库已然成为项目开发中必不可少的选择。

互联网发展到今天，每一个项目从产品立项到最终上线已经基本成流水化作业。环环相扣，这是团队内部有效沟通提升效率的必然结果。前端开发作为其中不可或缺的一环，自然也要从自身寻找可以改进或者提升的地方，以使效率最大化。模块化开发就是其中一项改进。

本篇讲述模块化出现的必然性，模块化能解决哪些问题，以及模块化规范定义等。

## 1. 功能划分

java有包、类等概念，面向对象特性明显，所以可以很容易的根据功能划分模块。单个java文件便是一个类来实现某个方法或者某个功能，其他地方需要用到某些功能，只需引入相应的包后调用即可。
  
前端开发最原始的思路是一个页面对应一个或多个js文件，根据依赖关系自上而下加载顺序执行。但是当某个页面交互逻辑非常复杂，往往我们写出一个超过几千行代码的js文件是轻而易举的事情。

而我们此时并不是在开发自己的某个类库或者框架，一个几千行代码的文件往往是后期维护人员的噩梦。尤其是代码质量不高的情况下，稍微的改动都要耗费巨大的精力。
  
## 2. 命名冲突

从一个简单的习惯出发。我们做项目时，常常会将一些通用的、底层的功能抽象出来，独立成一个个函数，比如最开始我们定义了一个功能函数<kbd>log：function log(){}</kbd>放在了utils.js文件里，后来团队中的其他人也恰好有个log差不多的需求，也提取抽象了出来，这时候发现log已经提前被我们用了，于是他命名log2...
  
如果团队或者项目不是很大，我们可以学习利用其他语言的命名空间的概念，来解决这个问题，比如定义一个toolsObj的命名空间：

``` javascript
var toolsObj = {};
toolsObj.log = function(str){
//...
}
```

这样需要调用这个函数时，得带上命名空间后再调用toolsObj.log(),虽然麻烦一点，不过能降低函数命名冲突的概率，可惜也只是降低而已。比如这里我随意取值toolsObj作为命名空间，但是公司几百号研发人员，想法相同的人肯定大有人在。所以命名空间依然有可能会冲突。那么为了继续降低冲突概率，只好拉长命名空间，比如学 Java用项目的网址做命名空间。

``` javascript
var toolsObj = {};
toolsObj.CoolSite = {};
toolsObj.CoolSite.Utils = {};

toolsObj.CoolSite.Utils.each = function (arr) {
  // 实现代码
};

toolsObj.CoolSite.Utils.log = function (str) {
  // 实现代码
};
```

下面这段代码节选自 Yahoo! 的一个开源项目：

``` javascript
if (org.cometd.Utils.isString(response)) {
    return org.cometd.JSON.fromJSON(response);
}
if (org.cometd.Utils.isArray(response)) {
    return response;
}
```

如此一来，调用一个公共方法需要记住n层命名空间，事情就变得很恶心了不是。
   
## 3. 文件依赖

js是运行在浏览器中的，js文件以script标签依次从上向下顺序加载，所以如果当B文件依赖A文件时，A文件就一定要在B文件加载之前加载。
  
当项目越来越复杂，众多文件之间的依赖经常会让人抓狂。下面这些问题，是经常面临且比较难以解决的。
  
- 通用组更新了前端基础类库，却很难推动全站升级。
- 业务组想用某个新的通用组件，但发现无法简单通过几行代码搞定。
- 一个老产品要上新功能，最后评估只能基于老的类库继续开发。
- 公司整合业务，某两个产品线要合并。结果发现前端代码冲突。
  
人肉管理文件依赖在稍大点的项目面前都是不可行的。
  
命名冲突和文件依赖，是前端开发过程中的两个经典问题。也是影响前端向着工程化发展的绊脚石，所以各种解决方案应运而生。

# 模块化方案

  目前，通行的Javascript模块规范：CommonJS、AMD和CMD。
  
## CommonJS

2009年，node诞生。与此同时模块化变编程概念也应运而生。node是运行在服务器端的javascript，不像web端，如果在服务器端没有模块化，很多工作根本无法进行。
  
摘抄几句CommonJs官网的译文：
  
> JavaScript是一个强大面向对象语言，它有很多快速高效的解释器。官方JavaScript标准定义的API是为了构建基于浏览器的应用程序。然而，并没有定于一个用于更广泛的应用程序的标准库。
CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以
使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。

在兼容CommonJS的系统中，你可以实用JavaScript程序开发：
  
- 服务器端JavaScript应用程序
- 命令行工具
- 图形界面应用程序
- 混合应用程序（如，Titanium或Adobe AIR）

nodejs和commonjs的关系：CommonJS是一种规范，NodeJS是这种规范的部分实现，也就是说nodejs中的模块加载只是commonjs宏伟蓝图中的一角而已。
  
[CommonJs官网](http://www.commonjs.org/)
  
CommonJs官网的slogan已经说的很明确： **javascript: not just for browsers any more!**
  
## AMD

CommonJs针对非浏览器端，其中有一个问题局限了它不能应用到浏览器端，便是同步加载。比如我们在写node应用的时候，需要什么模块直接require便可以，此时，
引用的模块也在服务端(相当于磁盘读写)，所以读取很快，但是当我们在浏览器端也采用这种形式的时候会出现那个很低级的问题，便是同步加载阻塞页面。
  
而AMD(Asynchronous Module Definition)异步模块定义采用异步方式加载模块，模块的加载不影响它后面语句的执行，所有依赖这个模块的语句，
都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

因为，浏览器端的模块，不能采用"同步加载"（synchronous），只能采用"异步加载"（asynchronous）。这就是AMD规范诞生的背景。
  
其实应该说是先出现了requirejs这个主推浏览器端模块化开发的类库，在推广过程中才形成了AMD这个产物。

[requirejs官网](http://www.requirejs.org/)

## CMD

CMD也是异步加载，目标也是浏览器端模块化开发，但是和AMD规范还是会有不一样的地方。

**@玉伯** 在推广seajs的过程中，CMD(通用模块定义)规范应运而生。

CommonJs、AMD、CMD三者是不同的概念，应加以区分。

先有node的诞生,模块化开发应运而生，node的模块加载依据CommonJs规范实现。由于在服务端是同步加载方式，该规范不能很好地应用到浏览器端，然后requirejs出现了，
在requirejs推广过程中，AMD(异步模块定义)规范作为产物出现。另外在异步这个条件下，**@玉伯** 又推出了seajs，CMD(通用模块定义)规范应运而生。
CommonJs针对服务端，目标是将javascript拓展到非浏览器端的服务端等其他宿主环境，模块化只是他诸多规范里其中的一点；AMD、CMD针对浏览器端，目标是为了解决文件
依赖等前端开发中常见的问题。


[知乎玉伯关于AMD和CMD的区别的回答](https://www.zhihu.com/question/20351507/answer/14859415)

[seajs官网](http://seajs.org/docs)

# 规范

CommonJs、AMD、CMD三者在规范定义上是有很多不同的，但是在最终的实现表现上还是有很多类似点的。不探究很细节的东西，只从形式上概括相同点。

## 定义模块 

根据规范，一个单独的文件就是一个模块,关键字define用来定义模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。
在node中，没有define关键字，每个单独的js文件便是一个模块，也就是一个单独的作用域。

## 模块标识

模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。

## 模块输出

模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象

## 模块引用

加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象

[类似文章](http://blog.csdn.net/jackwen110200/article/details/52105493)
