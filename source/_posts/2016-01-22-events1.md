---
title: 事件(一)-相关概念
author: Yeluo
tags: [javascript]
date: 2016-01-22
---


javascript关于事件有很多内容可讲，像冒泡捕获这些老生常谈的概念这里就简单整理下，重点讲述zepto中event模块源码解析和自定义事件的实现思路等。限于篇幅，此篇只介绍事件的相关概念。

# 事件模型

从DOM0到DOM3，每一级别的规范定义都是前者的完善和补充。我们先从DOM0开始。

## DOM0

DOM0事件模型，所有的浏览器都支持。

1.DOM0中注册事件形式如下：

``` javascript
var btnElm = document.getElementById("test");
btnElm.onclick = function(e){
console.log(e);
console.log(event);
console.log(arguments[0]);
console.log(this);
};
```

- 事件被触发时，浏览器会默认传入一个参数event，表示事件对象。通过e，我们可以获取很多有用的信息，比如点击的坐标、具体触发该事件的dom元素等等。获取event对象的方法包括直接在事件函数内引用event变量(前提是event没有被显示声明过，不然就会被覆盖了)、取传参的第一个参数、或者取arguments的第一个元素。
- 此种方式的事件绑定，处理函数中的this指向触发元素。

2.还可以直接写在html标签属性里。

``` javascript
<div id='btn' onclick="print(event)"><div>
```

这种杂糅的代码你想看吗？所以尽量不要写这样的烂代码出来。这里是为了说明问题。

- 这里获取event对象只能如上这样显示传参而且必须为event。
- 此处的处理函数中的this指向全局对象

3.解除绑定

如上此种绑定方式遵循覆盖原则，即后边的函数表达式会覆盖之前的，你会发现最后有效的是最后的绑定。也限制了一个DOM节点不能同时绑定多个事件。

因此，解除某个DOM节点的事件绑定就很好理解了。直接将事件句柄(handler)置为null即可。

## DOM2

不要问为什么不是DOM1，DOM1没定义不可以么？

DOM1中仅仅是引入了单事件绑定，DOM2增加了多事件绑定和捕获冒泡概念等，通过addEventListener和removeEventListener管理。但是！但是！IE8及以下的IE版本都不支持这两个事件管理函数，而是自己搞出了对应的attachEvent和detachEvent，真的是哦，怕兼容性的坑还不够深。不过庆幸的是，IE9中这两个函数已经被弃用，IE11中直接去除，所以我们简单提下，兼容性代码在高级浏览器中可以不考虑。

### 捕获和冒泡

> 事件触发过程：

{% img [] http://ojd8i48oc.bkt.clouddn.com/2016-10-15events1/event_capture.jpg 350 %}

**事件触发过程：**

当我们在 DOM 树(发生在DOM节点的事件谈冒泡和捕获才有意义)的某个节点发生了一些操作（例如单击、鼠标移动上去），就会有一个事件发射过去。这个事件从 Window 发出，不断经过下级节点直到目标节点。在到达目标节点之前的过程，就是`捕获阶段`（Capture Phase）。

所有经过的节点，都会触发这个事件。捕获阶段的任务就是建立这个事件传递路线，以便后面冒泡阶段顺着这条路线返回 Window。

当事件跑啊跑，跑到了事件触发目标节点那里，最终在目标节点上触发这个事件，就是`目标阶段`（Target Phase）。

当事件达到目标节点之后，就会沿着原路返回，由于这个过程类似水泡从底部浮到顶部，所以称作`冒泡阶段`（Bubbling Phase）。

总结：所以针对每个DOM节点触发的事件都是从window(个人理解这里可以理解为根节点即可，所以更确切的说是document)开始，不断经过下级节点直到目标节点，然后再按照捕获阶段的路径原路返回。这就是整个的事件触发过程。

addEventListener中的第三个参数为true则将事件设置为在捕获阶段发生，否则事件发生在冒泡阶段。

还有一点就是IE他不支持事件捕获，你说气不气人。

### 事件绑定和解绑

addEventListener负责事件绑定，不过DOM2中支持多事件绑定，即同一个DOM节点通过addEventListener绑定的不同的事件可以同时存在不被覆盖，按照声明顺序先后执行。关于事件对象的获取和this的指向同DOM0。removeEventListener的用法比较苛刻，三个参数共通决定解除哪一个事件绑定，缺一不可。

### 事件代理

事件代理是建立在事件冒泡机制上的，

``` html
<ul>
<li>1</li>
<li>2</li>
<li>3</li>
<li>4</li>
<li>5</li>
</ul>
```

假如有上面的五个li标签，如果不采取代理方式，要想同时监听他们的事件的话要分别在每个标签上都绑定事件。一个是性能，另一个是代码的冗余度。还好这里是五个，假如是50个，500个呢？不是要死人了。

根据事件冒泡机制，我们可以在ul上绑定事件监听，当事件进行到冒泡阶段的时候，我们便可以监听到该事件的发生。这样只需要进行一个事件的绑定即可。

使用事件代理主要有两个优势：

- 减少事件绑定，提升性能。之前你需要绑定一堆子节点，而现在你只需要绑定一个父节点即可。减少了绑定事件监听函数的数量。
- 动态变化的 DOM 结构，仍然可以监听。当一个 DOM 动态创建之后，不会带有任何事件监听，除非你重新执行事件监听函数，而使用事件代理无须担忧这个问题。

DOM0和DOM2的事件绑定混合在一起用的话，各自遵循自己的规则，互不影响。整体上来说，依然是哪个先注册，哪个先执行，其他就没什么了。